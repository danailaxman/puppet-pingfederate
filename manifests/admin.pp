# Class pingfederate::admin
# Runtime configuration of the server.
# Invokes pf-admin-api and edits various related XML config files.
# And may need to cause it to restart -- which is circular!
class pingfederate::admin inherits ::pingfederate {
  # This may take 30 seconds or so upon server startup. 
  # Waiting happens in bin/pf-admin-api (it retries on EConnRefused).
  exec {'pf-admin-api version':
    command => "${::pingfederate::install_dir}/local/bin/pf-admin-api version | grep version",
    user        =>  $::pingfederate::owner,
    logoutput   => true,
  }
  #
  # Configure the oauth JDBC service.
  #
  # The value of the fact named $::pingfederate::oauth_jdbc_url is the JNDI name.
  # Unfortunately the 'clean' way to do this is to invoke the pf-admin-api to add the database connector
  # and then edit two XML files, adding the JNDI-NAME to one of them, which requires restarting the service.
  # The 'dirty' way would be to just edit the datastore XML file that gets created by the pf-admin-api,
  # but who knows what other things that API might do?

  # this file is input to the pf-admin-api POST to define a new JDBC datastore
  # if it appears for the first time (or changes), that triggers invoking the API.
  # TODO: Deal with a change that breaks things.
  $ds = "${::pingfederate::install_dir}/local/etc/dataStores.json"
  file {$ds:
    ensure   => 'present',
    mode     => 'u=r,go=',
    owner    => $::pingfederate::owner,
    group    => $::pingfederate::group,
    content  => template('pingfederate/dataStores.json.erb')
  } ~> 
  exec {'pf-admin-api POST dataStores':
    command     => "${::pingfederate::install_dir}/local/bin/pf-admin-api -m POST -j ${ds} dataStores >${ds}.out",
    creates     => "${ds}.out",
    refreshonly => true,
    user        =>  $::pingfederate::owner,
    logoutput   => true,
  }
  # ERROR: The external fact is loaded before it is set the first time. The next time puppet runs it gets fixed.
  # TODO: Replace the external fact to use a file generated by pf-admin-api instead of this augeas stuff.
  # This effectively makes the one exec command invoke the API and edit the necessary files, "fixing"
  # the dumb app logic (which should just edit these files as part of the API call).
  if "${facts[$::pingfederate::oauth_jdbc_url]}" != '' {
    $hive_file = "$::pingfederate::install_dir/server/default/conf/META-INF/hivemodule.xml"
    augeas{$hive_file:
      lens    => 'Xml.lns',
      incl    => $hive_file,
      context => "/files/${hive_file}",
      changes => ['set module/service-point[#attribute/id="ClientManager"][#attribute/interface="org.sourceid.oauth20.domain.ClientManager"]/invoke-factory/construct/#attribute/class "org.sourceid.oauth20.domain.ClientManagerJdbcImpl"']
    }
    $jdbc_file = "$::pingfederate::install_dir/server/default/data/config-store/org.sourceid.oauth20.domain.ClientManagerJdbcImpl.xml"
    augeas{$jdbc_file:
      lens    => 'Xml.lns',
      incl    => $jdbc_file,
      context => "/files/${jdbc_file}",
      changes => ["set c:config/c:item[#attribute/name=\"PingFederateDSJNDIName\"]/#text \"${facts[$::pingfederate::oauth_jdbc_url]}\""],
      notify  => Exec['/sbin/service pingfederate restart'],
    }
  }
  # ugh. This is what happens when trying to notify the service class causes a dependency loop.
  exec {'/sbin/service pingfederate restart':
    refreshonly => true,
  }
}

